#!/usr/bin/env ruby
require 'nokogiri'
require 'open-uri'
require 'matrix'
require 'optparse'
require_relative 'lib/knot'

Point = Knot::Point

class Grid < Matrix
  attr_reader :position

  def position x, y
    @position = Vector[x, y]
    self[*@position]
  end

  def rel x, y
    self[*@position + Vector[x, y]]
  end

  def n
    rel -1, 0
  end

  def ne
    rel -1, 1
  end

  def e
    rel 0, 1
  end

  def se
    rel 1, 1
  end

  def s
    rel 1, 0
  end

  def sw
    rel 1, -1
  end

  def w
    rel 0, -1
  end

  def nw
    rel -1, -1
  end

  def n2
    rel -2, 0
  end

  def ne2
    rel -2, 2
  end

  def e2
    rel 0, 2
  end

  def se2
    rel 2, 2
  end

  def s2
    rel 2, 0
  end

  def sw2
    rel 2, -2
  end

  def w2
    rel 0, -2
  end

  def nw2
    rel -2, -2
  end
end

class Path
  def initialize
    @path = []
  end

  def M(m)
    @path.push __method__, m.x, m.y
  end

  def m(m)
    @path.push __method__, m.x, m.y
  end

  def L(m)
    @path.push __method__, m.x, m.y
  end

  def l(m)
    @path.push __method__, m.x, m.y
  end

  def A(rx, ry, x_axis_rotation, large_arc, sweep, m)
    @path.push __method__, rx, ry, x_axis_rotation, large_arc, sweep, m.x, m.y
  end

  def z
    @path.push 'z'
    @path.join(' ')
  end
end

class Cell
  attr_reader :c, :i, :o

  def initialize(c, inner, stroke)
    outer = inner + stroke

    @c = c

    pos = {
      n: [0, -1], ne: [0.5, -0.5], e: [1, 0], se: [0.5, 0.5],
      s: [0, 1], sw: [-0.5, 0.5], w: [-1, 0], nw: [-0.5, -0.5]
    }

    @i = pos.each_with_object({}) do |(k, v), a|
      a[k] = Point[c.x + v[0] * inner,
                   c.y + v[1] * inner]
    end

    @o = pos.each_with_object({}) do |(k, v), a|
      a[k] = Point[c.x + v[0] * outer,
                   c.y + v[1] * outer]
    end

    subpos = [
      [:n, :sw], [:n, :se],
      [:e, :sw], [:e, :nw],
      [:s, :nw], [:s, :ne],
      [:w, :ne], [:w, :se],
    ]
    subpos.each do |v|
      sym = (v[0].to_s << '_' << v[1].to_s).to_sym
      @o[sym] = Point[@o[v[0]].x + stroke * pos[v[1]][0],
                      @o[v[0]].y + stroke * pos[v[1]][1]]
    end
  end
end

def create_grid(knot_width, stroke_width)
  Grid.build(ROWS, COLS) do |i, j|
    c = Point[GRIDSIZE * j + GRIDSIZE / 2,
              GRIDSIZE * i + GRIDSIZE / 2]
    Cell.new(c, knot_width, stroke_width)
  end
end

def draw_grid(doc, svg, grid)
  Nokogiri::XML::Node.new 'g', doc do |g|
    svg.add_child g
    g[:fill] = 'white'

    grid.each do |a|
      Nokogiri::XML::Node.new 'circle', doc do |circle|
        g.add_child circle
        circle[:cx] = a.c.x
        circle[:cy] = a.c.y
        circle[:r] = 1
      end
    end
  end

  Nokogiri::XML::Node.new 'g', doc do |g|
    svg.add_child g
    g[:fill] = 'cyan'

    grid.each do |a|
      a.i.each do |k, v|
        Nokogiri::XML::Node.new 'circle', doc do |circle|
          g.add_child circle
          circle[:cx] = v.x
          circle[:cy] = v.y
          circle[:r] = 1
        end
      end
    end

    grid.each do |a|
      a.o.each do |k, v|
        Nokogiri::XML::Node.new 'circle', doc do |circle|
          g.add_child circle
          circle[:cx] = v.x
          circle[:cy] = v.y
          circle[:r] = 1
        end
      end
    end
  end
end

def draw_mask(grid)
  d = Path.new
  grid.position 1, 1
  r = Point.distance(grid.w.o[:e], grid.n.o[:s]) / 2

  # Fill diamonds.
  (2..(ROWS-3)).step(2) do |i|
    (2..(COLS-3)).step(2) do |j|
      grid.position i, j

      d.M grid.n.o[:s]
      d.L grid.e.o[:w]
      d.L grid.s.o[:n]
      d.L grid.w.o[:e]
    end
  end
  (3..(ROWS-4)).step(2) do |i|
    (3..(COLS-4)).step(2) do |j|
      grid.position i, j

      d.M grid.n.o[:s]
      d.L grid.e.o[:w]
      d.L grid.s.o[:n]
      d.L grid.w.o[:e]
    end
  end
  
  # NW Diamond.
  grid.position 1, 1
  d.M grid.e.o[:w]
  d.L grid.s.o[:n]
  d.L Point.midpoint(grid.s.o[:n], grid.w.o[:e])
  d.A r, r, 0, 0, 1, Point.midpoint(grid.n.o[:s], grid.e.o[:w])

  # N Diamonds.
  (3..(COLS-4)).step(2) do |j|
    grid.position 1, j
    d.M grid.e.o[:w]
    d.L grid.s.o[:n]
    d.L grid.w.o[:e]
    d.L Point.midpoint(grid.w.o[:e], grid.n.o[:s])
    d.A r, r, 0, 0, 1, Point.midpoint(grid.n.o[:s], grid.e.o[:w])
  end

  # NE Diamond.
  grid.position 1, COLS-2
  d.M grid.s.o[:n]
  d.L grid.w.o[:e]
  d.L Point.midpoint(grid.n.o[:s], grid.w.o[:e])
  d.A r, r, 0, 0, 1, Point.midpoint(grid.s.o[:n], grid.e.o[:w])

  # E Diamonds.
  (3..(ROWS-4)).step(2) do |i|
    grid.position i, COLS-2
    d.M grid.s.o[:n]
    d.L grid.w.o[:e]
    d.L grid.n.o[:s]
    d.L Point.midpoint(grid.e.o[:w], grid.n.o[:s])
    d.A r, r, 0, 0, 1, Point.midpoint(grid.s.o[:n], grid.e.o[:w])
  end

  # SE Diamond.
  grid.position ROWS-2, COLS-2
  d.M grid.w.o[:e]
  d.L grid.n.o[:s]
  d.L Point.midpoint(grid.n.o[:s], grid.e.o[:w])
  d.A r, r, 0, 0, 1, Point.midpoint(grid.s.o[:n], grid.w.o[:e])

  # S Diamonds.
  (COLS-4).step(3, -2) do |j|
    grid.position ROWS-2, j
    d.M grid.w.o[:e]
    d.L grid.n.o[:s]
    d.L grid.e.o[:w]
    d.L Point.midpoint(grid.s.o[:n], grid.e.o[:w])
    d.A r, r, 0, 0, 1, Point.midpoint(grid.s.o[:n], grid.w.o[:e])
  end

  # SW Diamond.
  grid.position ROWS-2, 1
  d.M grid.n.o[:s]
  d.L grid.e.o[:w]
  d.L Point.midpoint(grid.s.o[:n], grid.e.o[:w])
  d.A r, r, 0, 0, 1, Point.midpoint(grid.n.o[:s], grid.w.o[:e])

  # W Diamonds.
  (ROWS-4).step(3, -2) do |i|
    a = grid.position i, 1
    d.M grid.n.o[:s]
    d.L grid.e.o[:w]
    d.L grid.s.o[:n]
    d.L Point.midpoint(grid.s.o[:n], grid.w.o[:e])
    d.A r, r, 0, 0, 1, Point.midpoint(grid.w.o[:e], grid.n.o[:s])
  end

  d.z
end

def draw_outline(grid)
  d = Path.new
  a = grid.position 1, 1
  r = Point.distance(a.o[:se], grid.nw.o[:nw]) / 2

  # NW Corner.
  a = grid.position 2, 1
  d.M a.o[:w]
  d.L Point.midpoint(a.o[:w], grid.nw.o[:s])
  d.A 1, 1, 0, 0, 1, Point.midpoint(grid.ne.o[:n], grid.n2.o[:e])

  # N Corners.
  (2..(COLS-5)).step(2) do |j|
    a = grid.position 1, j
    d.L a.o[:n]
    d.L Point.midpoint(a.o[:n], grid.ne.o[:w])
    d.A r, r, 0, 0, 1, Point.midpoint(grid.ne.o[:e], grid.e2.o[:n])
  end

  # NE Corner.
  a = grid.position 1, COLS-3
  d.L a.o[:n]
  d.L Point.midpoint(a.o[:n], grid.ne.o[:w])
  d.A 1, 1, 0, 0, 1, Point.midpoint(grid.e2.o[:s], grid.se.o[:e])

  # E Corners.
  (2..(ROWS-5)).step(2) do |i|
    a = grid.position i, COLS-2
    d.L a.o[:e]
    d.L Point.midpoint(a.o[:e], grid.se.o[:n])
    d.A r, r, 0, 0, 1, Point.midpoint(grid.se.o[:s], grid.s2.o[:e])
  end

  # SE Corner.
  a = grid.position ROWS-3, COLS-2
  d.L a.o[:e]
  d.L Point.midpoint(a.o[:e], grid.se.o[:n])
  d.A 1, 1, 0, 0, 1, Point.midpoint(grid.sw.o[:s], grid.s2.o[:w])

  # S Corners.
  (COLS-3).step(4, -2) do |j|
    a = grid.position ROWS-2, j
    d.L a.o[:s]
    d.L Point.midpoint(a.o[:s], grid.sw.o[:e])
    d.A r, r, 0, 0, 1, Point.midpoint(grid.sw.o[:w], grid.w2.o[:s])
  end

  # SW Corner.
  a = grid.position ROWS-2, 2
  d.L a.o[:s]
  d.L Point.midpoint(a.o[:s], grid.sw.o[:e])
  d.A 1, 1, 0, 0, 1, Point.midpoint(grid.nw.o[:w], grid.w2.o[:n])

  # W Corners.
  (ROWS-3).step(4, -2) do |i|
    a = grid.position i, 1
    d.L a.o[:w]
    d.L Point.midpoint(a.o[:w], grid.nw.o[:s])
    d.A r, r, 0, 0, 1, Point.midpoint(grid.nw.o[:n], grid.n2.o[:w])
  end

  d.z
end

def draw_knot(grid)
  d = Path.new
  a = grid.position 2, 2
  mp = Point.midpoint(a.i[:w], grid.nw.i[:s])
  sm_r = Point.distance(mp, grid.w.c)
  mp = Point.midpoint(grid.nw.i[:w], grid.w2.i[:n])
  b_r = Point.distance(mp, grid.w.c)

  # Diagonals right.
  (1..(ROWS-3)).step(2) do |i|
    (2..(COLS-5)).step(2) do |j|
      a = grid.position i, j

      d.M a.o[:e_sw]
      d.L grid.se2.o[:n_sw]
      d.L grid.se2.o[:w_ne]
      d.L a.o[:s_ne]
    end
  end

  # Diagonals left.
  (4..(ROWS-2)).step(2) do |i|
    (1..(COLS-4)).step(2) do |j|
      a = grid.position i, j

      d.M a.o[:e_nw]
      d.L grid.ne2.o[:s_nw]
      d.L grid.ne2.o[:w_se]
      d.L a.o[:n_se]
    end
  end

  # Bends N
  (4..(COLS-3)).step(2) do |j|
    a = grid.position 1, j
    b = grid.rel 1, -3

    d.M a.o[:w_ne]
    d.L Point.midpoint(a.i[:w], grid.nw.i[:s])
    Point.distance(mp, grid.w.c)
    d.A sm_r, sm_r, 0, 0, 0, Point.midpoint(grid.w2.i[:e], grid.nw.i[:s])
    d.L b.o[:e_nw]
    d.L b.o[:n_se]
    d.L Point.midpoint(grid.nw.i[:w], grid.w2.i[:n])
    d.A b_r, b_r, 0, 0, 1, Point.midpoint(a.i[:n], grid.nw.i[:e])
    d.L a.o[:n_sw]
  end
  
  # Bend NE
  a = grid.position 2, COLS-4
  b = grid.rel -1, 3

  d.M a.o[:n_se]
  d.L Point.midpoint(grid.ne.i[:n], grid.ne2.i[:w])
  d.A b_r, b_r, 0, 0, 1, Point.midpoint(grid.e2.i[:e], b.i[:s])
  d.L grid.e2.o[:e_nw]
  d.L grid.e2.o[:n_se]
  d.L Point.midpoint(grid.e2.i[:n], b.i[:w])
  d.A sm_r, sm_r, 0, 0, 0, Point.midpoint(grid.ne.i[:e], grid.ne2.i[:s])
  d.L a.o[:e_nw]

  # Bends E
  (1..(ROWS-6)).step(2) do |i|
    a = grid.position i, COLS-3

    b = grid.rel 3, 1
    d.M a.o[:e_sw]
    d.L Point.midpoint(grid.se.i[:e], grid.se2.i[:n])
    d.A b_r, b_r, 0, 0, 1, Point.midpoint(grid.se2.i[:s], b.i[:e])
    d.L b.o[:e_nw]
    d.L b.o[:n_se]
    d.L Point.midpoint(grid.se2.i[:w], b.i[:n])
    d.A sm_r, sm_r, 0, 0, 0, Point.midpoint(grid.se.i[:s], grid.se2.i[:w])
    d.L a.o[:s_ne]
  end

  # Bend SE
  a = grid.position ROWS-2, COLS-3
  d.M a.o[:e_sw]
  d.L Point.midpoint(a.i[:e], grid.se.i[:n])
  d.A 1, 1, 0, 0, 0, Point.midpoint(grid.ne.i[:s], grid.e2.i[:w])
  d.L grid.n2.o[:s_ne]
  d.L grid.n2.o[:e_sw]
  d.L Point.midpoint(grid.ne.i[:e], grid.e2.i[:n])
  d.A 1, 1, 0, 0, 1, Point.midpoint(a.i[:s], grid.se.i[:w])
  d.L a.o[:s_ne]

  # Bends S
  (2..(COLS-5)).step(2) do |j|
    a = grid.position ROWS-2, j

    b = grid.rel -1, 3
    d.M a.o[:e_sw]
    d.L Point.midpoint(a.i[:e], grid.se.i[:n])
    d.A sm_r, sm_r, 0, 0, 0, Point.midpoint(grid.se.i[:n], grid.e2.i[:w])
    d.L b.o[:w_se]
    d.L b.o[:s_nw]
    d.L Point.midpoint(grid.se.i[:e], grid.e2.i[:s])
    d.A b_r, b_r, 0, 0, 1, Point.midpoint(a.i[:s], grid.se.i[:w])
    d.L a.o[:s_ne]
  end

  # Bend SW
  a = grid.position ROWS-3, 1
  d.M a.o[:s_nw]
  d.L Point.midpoint(a.i[:s], grid.sw.i[:e])
  d.A sm_r, sm_r, 0, 0, 0, Point.midpoint(grid.s2.i[:n], grid.se.i[:w])
  d.L grid.e2.o[:w_se]
  d.L grid.e2.o[:s_nw]
  d.L Point.midpoint(grid.s2.i[:e], grid.se.i[:s])
  d.A b_r, b_r, 0, 0, 1, Point.midpoint(a.i[:w], grid.sw.i[:n])
  d.L a.o[:w_se]

  # Bends W
  (2..(ROWS-5)).step(2) do |i|
    a = grid.position i, 1
    b = grid.rel 3, 1

    d.M a.o[:s_nw]
    d.L Point.midpoint(a.i[:s], grid.sw.i[:e])
    d.A sm_r, sm_r, 0, 0, 0, Point.midpoint(grid.sw.i[:e], grid.s2.i[:n])
    d.L b.o[:n_sw]
    d.L b.o[:w_ne]
    d.L Point.midpoint(grid.sw.i[:s], grid.s2.i[:w])
    d.A b_r, b_r, 0, 0, 1, Point.midpoint(a.i[:w], grid.sw.i[:n])
    d.L a.o[:w_se]
  end

  # Bend NW
  a = grid.position 1, 2
  d.M a.o[:w_ne]
  d.L Point.midpoint(a.i[:w], grid.nw.i[:s])
  d.A sm_r, sm_r, 0, 0, 0, Point.midpoint(grid.w2.i[:e], grid.sw.i[:n])
  d.L grid.s2.o[:n_sw]
  d.L grid.s2.o[:w_ne]
  d.L Point.midpoint(grid.w2.i[:s], grid.sw.i[:w])
  d.A b_r, b_r, 0, 0, 1, Point.midpoint(a.i[:n], grid.nw.i[:e])
  d.L a.o[:n_sw]

  d.z
end

options = {
  vertical: 2,
  horizontal: 2,
  grid_size: 96,
  knot_color: 'white',
  knot_width: 24,
  stroke_color: 'black',
  stroke_width: 8,
}
OptionParser.new do |opts|
  opts.banner = "Usage: ./knot [options]"

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end

  opts.on("-VVERTICAL", "--vertical=VERTICAL", "Number of cells vertically.") do |opt|
    options[:vertical] = opt
  end

  opts.on("-HHORIZONTAL", "--horizontal=HORIZONTAL", "Number of cells horizontally.") do |opt|
    options[:horizontal] = opt
  end

  opts.on("-GGRID_SIZE", "--grid-size=GRID_SIZE", "Dimensions of each cell in the grid.") do |opt|
    options[:grid_size] = opt
  end

  opts.on("-bBG_COLOR", "--background-color=BG_COLOR", "Background colour.") do |opt|
    options[:background_color] = opt
  end

  opts.on("-kKNOT_COLOR", "--knot-color=KNOT_COLOR", "Knot colour.") do |opt|
    options[:knot_color] = opt
  end

  opts.on("-KKNOT_WIDTH", "--knot-width=KNOT_WIDTH", "Knot width.") do |opt|
    options[:knot_width] = opt
  end

  opts.on("-sSTROKE_COLOR", "--stroke-color=STROKE_COLOR", "Stroke colour.") do |opt|
    options[:stroke_color] = opt
  end

  opts.on("-SSTROKE_WIDTH", "--stroke-width=STROKE_WIDTH", "Stroke width.") do |opt|
    options[:stroke_width] = opt
  end
end.parse!

ROWS = options[:vertical].to_i * 2 + 1
COLS = options[:horizontal].to_i * 2 + 1
GRIDSIZE = options[:grid_size].to_i
W = GRIDSIZE * COLS
H = GRIDSIZE * ROWS

grid = create_grid options[:knot_width].to_i, options[:stroke_width].to_i
doc = Nokogiri::XML::Document.new

Nokogiri::XML::Node.new 'svg', doc do |svg|
  doc.add_child svg
  svg[:xmlns] = 'http://www.w3.org/2000/svg'
  svg[:viewBox] = "0 0 #{W} #{H}"
  svg[:width] = W
  svg[:height] = H

  bg_d = "M0,0 v#{H} h#{W} v-#{H} z";

  # Background.
  Nokogiri::XML::Node.new 'path', doc do |path|
    svg.add_child path
    path[:d] = bg_d
    path[:fill] = options[:background_color]
  end if options[:background_color]

  # Stroke Mask
  Nokogiri::XML::Node.new 'mask', doc do |mask|
    svg.add_child mask
    mask[:id] = 'strokeMask'

    Nokogiri::XML::Node.new 'path', doc do |path|
      mask.add_child path
      path[:d] = bg_d
      path[:fill] = 'white'
    end

    # Mask
    Nokogiri::XML::Node.new 'path', doc do |path|
      mask.add_child path
      path[:d] = draw_mask grid
      path[:fill] = 'black'
    end
  end


  # Outline stroke
  Nokogiri::XML::Node.new 'g', doc do |g|
    svg.add_child g
    g[:fill] = options[:stroke_color]
    g[:mask] = 'url(#strokeMask)'

    Nokogiri::XML::Node.new 'path', doc do |path|
      g.add_child path
      path[:d] = draw_outline grid
    end
  end

  # Knot line
  Nokogiri::XML::Node.new 'g', doc do |g|
    svg.add_child g
    g[:fill] = options[:knot_color]

    Nokogiri::XML::Node.new 'path', doc do |path|
      g.add_child path
      path[:d] = draw_knot grid
    end
  end

  #draw_grid doc, svg, grid
end

puts doc.to_xml indent:2
